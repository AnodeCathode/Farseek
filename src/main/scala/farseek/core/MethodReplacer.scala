package farseek.core

import farseek.util.Reflection._
import farseek.util._
import org.objectweb.asm.Label
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.Type._
import org.objectweb.asm.commons.GeneratorAdapter
import org.objectweb.asm.commons.GeneratorAdapter._
import scala.collection.mutable

/** A [[ClassPatcher]] that replaces any method matching the provided [[MethodReplacement]] with an implementation that
  * calls a static method specified by the replacement. This method must have the same parameters as the replaced method,
  * plus a [[ReplacedMethod]] argument for calling the original method implementation (created here as a new method,
  * with an aliased name). If replacing a non-static method, the replacement method must also have an additional
  * parameter for the receiving instance.
  *
  * The original method implementation will have one prefix in its name. Each successive replacement adds a new prefix
  * in the chain. For example:
  *
  * `method` (2nd replacement) `->` `REPLACED_REPLACED_method` (1st replacement) `->` `REPLACED_method` (original)
  *
  * Methods are matched by name/descriptor only, without knowledge of whether the visited class is a subclass of the one
  * specified by `replacement`. This is to avoid loading other classes in search of a superclass, which often causes
  * problems in FML. (Stack frames are manually visited instead of generated by COMPUTE_FRAMES in the class writer, for
  * the same reason.) The replacement method includes a runtime check for compatibility with the replacement-specified
  * class, and directly calls the original implementation if not the same or a subclass of that class.
  *
  * @author delvr
  */
class MethodReplacer(bytecode: Array[Byte], className: String, replacement: MethodReplacement)
        extends ClassPatcher(bytecode) {

    import farseek.core.MethodReplacement._
    import farseek.core.ReplacedMethodFactory._

    private val methodReplacements = mutable.Map[String, mutable.Set[MethodReplacement]]().withDefaultValue(mutable.Set())

    override def visitMethod(accessFlags: Int, name: String, descriptor: String, signature: String, exceptions: Array[String]) = {
        val writer = super.visitMethod(accessFlags, name, descriptor, signature, exceptions)
        val isStatic   = hasFlag(accessFlags, ACC_STATIC)
        val isAbstract = hasFlag(accessFlags, ACC_ABSTRACT)
        // Don't visit abstract, non-matching, or static different-class methods (they can't be overrides of `name`).
        if(isAbstract || !replacement.matches(name, descriptor) || (isStatic && className != replacement.className))
            writer
        else {
            val replacements = methodReplacements(replacement.devName)
            replacements += replacement
            val delegateMethodName = replacements.map(_ => ReplacementPrefix).mkString + replacement.devName
            val delegatorWriter = new GeneratorAdapter(writer, accessFlags, name, replacement.descriptor)
            replaceMethod(delegateMethodName, delegatorWriter, replacement, isStatic)
            trace(s"Renaming original method $className.$name to $delegateMethodName")
            super.visitMethod(accessFlags, delegateMethodName, descriptor, signature, exceptions)
        }
    }

    private def replaceMethod(aliasedName: String, visitor: GeneratorAdapter, replacement: MethodReplacement, isStatic: Boolean) {
        val replacementType = getType(replacement.className)
        val parameterTypes = parameterFrameTypes(replacement.descriptor)
        val localTypes = if(isStatic) parameterTypes else className +: parameterTypes
        val returnType = if(replacement.descriptor.endsWith(")V")) Array[AnyRef]()
                         else Array(returnFrameType(replacement.descriptor))
        val endLabel = new Label
        visitor.visitCode()
        if(className == replacement.className)
            debug(s"Patching method ${replacement.names} on class $className")
        else { // Create a runtime check to see if this is a subclass of replacement.className
            trace(s"Patching method ${replacement.names} on possible subclass of ${replacement.className}: $className")
            val replacementLabel = new Label
            visitor.loadThis()
            visitor.instanceOf(replacementType)
            visitor.ifZCmp(NE, replacementLabel) // If class is compatible, skip ahead to replacementLabel
            visitor.loadThis()
            visitor.loadArgs()
            // Call the original implementation
            visitor.visitMethodInsn(INVOKESPECIAL, className, aliasedName, replacement.descriptor, false)
            visitor.goTo(endLabel)
            visitor.visitFrame(F_NEW, localTypes.length, localTypes, 0, null)
            visitor.mark(replacementLabel)
        }
        // Create ReplacedMethod object to pass to replacement method so it can call the original (aliased) implementation
        visitor.loadArgs()
        visitor.push(className)
        visitor.push(aliasedName)
        visitor.push(replacement.descriptor)
        visitor.visitMethodInsn(INVOKESTATIC, "farseek/core/ReplacedMethodFactory", "apply",
            s"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)$ReplacementMethodType", false)
        if(!isStatic) {
            visitor.loadThis()
            visitor.checkCast(replacementType)
        }
        // Call the replacement method
        visitor.visitMethodInsn(INVOKESTATIC, replacement.replacementClass, replacement.replacementMethod,
            replacement.descriptor.replace(")",
                ReplacementMethodType + textIf(!isStatic, typeDescriptor(replacement.className)) + ")"), false)
        visitor.mark(endLabel)
        visitor.visitFrame(F_NEW, localTypes.length, localTypes, returnType.length, returnType)
        visitor.returnValue()
        visitor.endMethod()
    }
}

/** A wrapper around a lazy-loaded [[java.lang.reflect.Method]] that can be called through the `apply()` method.
  * @author delvr
  */
class ReplacedMethod[T >: Null](className: String, name: String, args: Class[_]*) {

    // We make sure to use FML's classloader so transformers can run
    private lazy val method = Class.forName(externalName(className), false,
        Thread.currentThread.getContextClassLoader).getDeclaredMethod(name, args:_*).accessible

    def apply[R](args: Any*)(implicit instance: T = null): R = method.apply(instance, args:_*)
}

/** A factory for [[ReplacedMethod]]s with a cache to ensure reflection lookups happen only once.
  * @author delvr
  */
object ReplacedMethodFactory {

    val ReplacementMethodType = typeDescriptor(classOf[ReplacedMethod[_]])

    private val cache = mutable.Map[String, ReplacedMethod[_]]()

    def apply(className: String, name: String, descriptor: String): ReplacedMethod[_] =
        cache.getOrElseUpdate(s"$className.$name$descriptor", newReplacedMethod(className, name, descriptor))

    private def newReplacedMethod(className: String, name: String, descriptor: String): ReplacedMethod[_] =
        new ReplacedMethod(className, name, parameterTypes(descriptor):_*)
}

